# Кэширование и производительность

Кэширование в Brick — это не оптимизация, а **философия уважения к ресурсам**. Каждый компонент знает, как можно кэшировать себя, но не навязывает стратегию.

---

## Два уровня кэширования

### 1. **Кэш метаданных** (всегда включён)
Brick автоматически кэширует:
- Пути к файлам компонентов
- Загруженные CSS и JavaScript
- Рефлексивные данные

**Это работает без вашего участия.** Просто повторные вызовы компонентов быстрее.

### 2. **Кэш рендеринга** (опционально)
Кэширование готового HTML через PSR-16 CacheInterface.

```php
use OlegV\Traits\WithCache;

class ProductCard extends Brick
{
    use WithCache;
}
```

---

## PSR-16: интерфейс, а не реализация

Brick работает с **любым PSR-16 совместимым кэшем**:
- Redis
- Memcached
- Файловый кэш
- APCu
- Ваша собственная реализация

```php
use Symfony\Component\Cache\Psr16Cache;

$cache = new Psr16Cache(
    new RedisAdapter($redisClient)
);

// Устанавливаем один раз
ProductCard::setCache($cache);
```

**Ваш компонент не знает**, где и как хранится кэш. Он только передаёт данные интерфейсу.

---

## Как работает кэширование рендеринга

1. **Ключ кэша** генерируется из:
    - Имени класса компонента
    - Значений всех публичных свойств
    - Конфигурации кэша

2. **При рендеринге:**
    - Проверяется наличие в кэше
    - Если есть — возвращается готовый HTML
    - Если нет — рендерится и сохраняется

3. **TTL настраивается:**
   ```php
   protected static int $cacheTtl = 3600; // секунды
   ```

---

## Стратегии кэширования

### 1. **Кэширование всего компонента**
```php
class StaticBlock extends Brick
{
    use WithCache;
    // Кэшируется полностью на 1 час
}
```

### 2. **Частичное кэширование**
```php
class ProductList extends Brick
{
    use WithCache;
    
    protected function getCacheHash(): string
    {
        // Кэшируем только по ID продуктов
        return md5(implode(',', $this->productIds));
    }
}
```

### 3. **Разные TTL для разных данных**
```php
class WeatherWidget extends Brick
{
    protected static int $cacheTtl = 300; // 5 минут для погоды
    
    use WithCache;
}
```

---

## Когда кэшировать?

### ✅ **Кэшируйте, когда:**
- Компонент рендерится дорого (тяжёлые запросы, вычисления)
- Данные меняются редко (статические блоки, навигация)
- Одинаковые данные используются многократно

### ❌ **Не кэшируйте, когда:**
- Данные уникальны для каждого запроса (персонализация)
- Компонент простой и быстрый (кнопка, заголовок)
- Нужна абсолютная актуальность (счётчики, время)

---

## Производительность без кэширования

Даже без явного кэширования Brick оптимизирован:

1. **Автозагрузка файлов** — только при первом использовании
2. **Рефлексия** — кэшируется на уровне PHP
3. **Ассеты** — собираются один раз на запрос
4. **Шаблоны** — подключаются через `include`, а не парсинг

---

## Мониторинг кэша

```php
$stats = Brick::getCacheStats();
// [
//     'cached_classes' => 15,
//     'css_assets' => 8,
//     'js_assets' => 5
// ]
```

---

## Инвалидация кэша

### Автоматическая:
- При изменении свойств компонента → новый хэш
- При истечении TTL → перегенерация

### Ручная:
```php
// Очистить все кэши компонента
Brick::clear();

// Или через ваш PSR-16 кэш
$cache->clear();
```

---

## Рекомендации по производительности

### Для высоконагруженных проектов:
1. Используйте **PSR-16 кэш** с быстрым бэкендом (Redis)
2. Настройте **разные TTL** для разных типов данных
3. **Минифицируйте ассеты** через FileAssetRenderer
4. Используйте **статичные компоненты** там, где возможно

### Для небольших проектов:
1. Включите **кэш метаданных** (он всегда работает)
2. Используйте **файловый кэш** для рендеринга
3. Не оптимизируйте преждевременно

---

## Философия

Кэширование в Brick — это **делегирование ответственности**:
- Компонент знает **что** кэшировать
- PSR-16 кэш знает **как** кэшировать
- Вы решаете **когда** кэшировать

> Хороший кэш — тот, который не замечают.  
> Он просто делает приложение быстрее, не требуя внимания.

---

## Что дальше?

- [Лучшие практики](./best-practices.md)

---

> Производительность — это не функция, которую добавляют в конце.  
> Это культура, которую выбирают в начале.