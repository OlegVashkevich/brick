# Наследование и композиция

В Brick наследование — это **опциональная возможность**, а не обязательное поведение. По умолчанию каждый компонент самостоятелен. Наследование включается явно, когда оно имеет смысл.

---

## Два режима работы

### 1. **Самостоятельный компонент** (по умолчанию)
Каждый компонент работает **изолированно**:
- Ищет свои файлы (`template.php`, `style.css`, `script.js`) только в своей директории
- Не знает о родителях
- Полностью автономен

```php
class Button extends Brick
{
    // Ищет файлы только в Button/
}
```

### 2. **Наследующий компонент** (с трейтом `WithInheritance`)
Компонент **осознаёт иерархию**:
- Может использовать файлы родительских компонентов
- Объединяет стили и скрипты по цепочке наследования
- Строит семантическую связь

```php
class PrimaryButton extends BaseButton
{
    use WithInheritance;
    // Ищет файлы в PrimaryButton/, затем в BaseButton/
}
```

---

## Когда включать наследование?

Включайте трейт `WithInheritance`, только когда:

1. **Есть явная семантическая связь** «является»
2. **Хотите переиспользовать шаблоны** родителя
3. **Нужно наследовать и дополнять стили/скрипты**

**Пример правильного использования:**
```
UI/
├── BaseFormField/
│   ├── BaseFormField.php
│   ├── template.php
│   └── style.css
└── TextInput/
    ├── TextInput.php  (extends BaseFormField, uses WithInheritance)
    └── style.css      // дополняет родительский CSS
```

---

## Механика поиска файлов

### Без трейта `WithInheritance`:
```
Button/
├── Button.php
├── template.php    ← используется этот
├── style.css       ← используется этот
└── script.js       ← используется этот
```

Если файла нет в папке компонента — он считается отсутствующим.

### С трейтом `WithInheritance`:
```
BaseButton/
├── BaseButton.php
├── template.php    ← используется, если нет у потомка
├── style.css       ← объединяется со стилями потомка
└── script.js       ← объединяется со скриптами потомка

PrimaryButton/
├── PrimaryButton.php  (extends BaseButton, uses WithInheritance)
├── template.php       ← приоритет над родительским
└── style.css          ← добавляется к родительскому
```

**Порядок поиска:**
1. Папка текущего компонента
2. Папка непосредственного родителя
3. И так далее до `Brick`

**Первый найденный `template.php` — используется.**  
**Стили и скрипты — объединяются от родителя к потомку.**

---

## Композиция: всегда доступна

Композиция не требует трейтов. Это **основной способ** построения сложных интерфейсов:

```php
class Card extends Brick
{
    public function __construct(
        public string $title,
        public Button $actionButton  // компонент внутри компонента
    ) {}
}
```

**Правило:**  
Если можно сделать через композицию — делайте через композицию.  
Наследование — для особых случаев.

---

## Пример: когда наследование оправдано

**BaseNotification.php:**
```php
abstract class BaseNotification extends Brick
{
    use WithInheritance;

    public function __construct(
        public string $message,
        public DateTime $timestamp
    ) {}
}
```

**SuccessNotification.php:**
```php
class SuccessNotification extends BaseNotification
{
    // Наследует template.php от BaseNotification
    // Добавляет свой style.css к родительскому
}
```

Здесь:
1. Оба компонента — уведомления (семантическая связь)
2. Общая разметка (`template.php`)
3. Общие базовые стили + специфичные дополнения

---

## Практические рекомендации

### Используйте наследование, когда:
- ✅ Есть общий **шаблон** для семейства компонентов
- ✅ Стили **логично дополняют** родительские
- ✅ Иерархия **стабильна** и понятна

### Избегайте наследования, когда:
- ❌ Хотите просто **переиспользовать код** (используйте трейты)
- ❌ Иерархия **искусственная** (лучше композиция)
- ❌ Компоненты **меняются независимо**

---

## Философия выбора

Brick даёт вам **инструменты**, а не диктует архитектуру:

- **По умолчанию** — компоненты независимы и просты
- **С трейтом** — можете строить глубокие иерархии
- **Всегда** — можете комбинировать компоненты через композицию

> Наследование в Brick — это **сознательное решение**, а не автоматическое поведение.  
> Включайте его только когда готовы нести ответственность за связь между компонентами.

---

## Что дальше?

- [Работа с ассетами](./assets.md) — как управлять стилями и скриптами в иерархиях
- [Кэширование](./caching.md) — производительность наследуемых компонентов
- [Лучшие практики](./best-practices.md) — антипаттерны наследования

---

> Хорошая архитектура компонентов — та, где каждый знает свои границы.  
> Наследование расширяет эти границы, но не стирает их.